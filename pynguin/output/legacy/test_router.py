# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import router as module_0
import sanic.constants as module_1
import collections.abc as module_2
import builtins as module_3
import abc as module_4


@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    router_0 = module_0.Router(
        method_handler_exception=none_type_0,
        route_class=none_type_0,
        group_class=none_type_0,
        stacking=none_type_0,
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert router_0.method_handler_exception is None
    assert router_0.route_class is None
    assert router_0.group_class is None
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is None
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    str_0 = 'l\\[afI(="'
    router_0.add(str_0, none_type_0, str_0, version=str_0, error_format=none_type_0)


def test_case_1():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0,
        none_type_0,
        type_0,
        strict_slashes=bool_0,
        ignore_body=type_0,
        version_prefix=str_0,
    )
    assert len(router_0.static_routes) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )


@pytest.mark.xfail(strict=True)
def test_case_2():
    type_0 = module_3.bytes
    type_1 = module_4.ABC
    type_2 = module_3.str
    bool_0 = False
    router_0 = module_0.Router(
        exception=type_0,
        method_handler_exception=type_1,
        route_class=type_2,
        stacking=bool_0,
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    str_0 = "iW3w;=S V;7#&I"
    bool_1 = True
    bool_2 = False
    bool_3 = True
    router_0.add(
        str_0,
        type_2,
        bool_1,
        strict_slashes=bool_0,
        unquote=bool_1,
        static=bool_2,
        version_prefix=type_2,
        overwrite=bool_3,
    )


def test_case_3():
    router_0 = module_0.Router()
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )


def test_case_4():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0,
        none_type_0,
        type_0,
        strict_slashes=bool_0,
        ignore_body=type_0,
        version_prefix=str_0,
    )
    assert len(router_0.static_routes) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    none_type_1 = router_0.finalize()
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    try:\n        group = router.static_routes[parts]\n        basket['__raw_path__'] = path\n        return group, basket\n    except KeyError:\n        pass\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    try:\n        group = router.static_routes[parts]\n        basket['__raw_path__'] = path\n        return (group, basket)\n    except KeyError:\n        pass\n    raise NotFound"
    )


@pytest.mark.xfail(strict=True)
def test_case_5():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "N}<*J7"
    router_1 = module_0.Router(str_0)
    router_0.add(str_1, router_0, var_0, none_type_0, name=str_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    bool_0 = False
    router_0 = module_0.Router(
        method_handler_exception=str_0, route_class=str_0, cascade_not_found=bool_0
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert router_0.method_handler_exception == 'l\\[afI(="'
    assert router_0.route_class == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    bool_1 = False
    none_type_0 = None
    router_1 = module_0.Router(
        exception=none_type_0, method_handler_exception=bool_0, cascade_not_found=type_0
    )
    bool_2 = True
    str_1 = "ui]_rb.|\x0b"
    router_0.add(str_1, bool_0, bool_0, bool_2, stream=bool_1)


def test_case_7():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    var_1 = var_0.reset()
    var_2 = router_0.finalize(do_optimize=none_type_0)
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )


@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "!+<C"
    router_0.add(str_1, str_0, type_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    bool_0 = True
    bool_1 = False
    str_1 = "A^|~s?n\t_N/@fq"
    none_type_0 = None
    bool_2 = False
    router_0.add(
        str_1,
        bool_1,
        none_type_0,
        strict_slashes=bool_2,
        name=bool_0,
        unquote=bool_2,
        overwrite=bool_0,
        error_format=router_0,
    )


@pytest.mark.xfail(strict=True)
def test_case_10():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    var_1 = var_0.__str__()
    assert var_1 == '<Route: name=l\\[afI(=" path=l\\[afI(=">'
    list_0 = []
    none_type_1 = router_0.finalize(*list_0)
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )
    router_1 = module_0.Router()
    type_1 = module_3.BaseException
    router_2 = module_0.Router(bool_0, type_1)
    router_1.add(
        var_1,
        var_1,
        type_0,
        stream=none_type_1,
        ignore_body=none_type_1,
        version=router_1,
        static=var_1,
    )


@pytest.mark.xfail(strict=True)
def test_case_11():
    type_0 = module_2.Iterable
    str_0 = 'l\\[afI(="'
    type_1 = module_2.Iterable
    router_0 = module_0.Router(str_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    router_0.add(
        str_0,
        none_type_0,
        type_0,
        none_type_0,
        bool_0,
        ignore_body=str_0,
        version=str_0,
        version_prefix=type_1,
        error_format=router_0,
    )


@pytest.mark.xfail(strict=True)
def test_case_12():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "R\r823N}<@J#7"
    type_1 = module_3.dict
    str_2 = "<(\r\x0ca*F2nV\x0c2Px7m[H"
    router_1 = module_0.Router(str_2, cascade_not_found=str_2)
    router_2 = module_0.Router(router_1, none_type_0, stacking=str_1)
    str_3 = "{mRuet)th2y#"
    var_1 = router_0.reset()
    str_4 = '1fG/:)FfPVZ)LSPvls"@'
    var_2 = var_0.parse_parameter_string(str_4)
    bool_1 = False
    router_0.add(str_3, var_1, var_1, var_2, type_1, name=str_4, static=bool_1)


@pytest.mark.xfail(strict=True)
def test_case_13():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    bool_1 = False
    str_1 = "!+<C"
    router_1 = module_0.Router(str_0)
    str_2 = "Yc:;^*\\~y\x0bMjBM\t"
    none_type_1 = router_0.finalize()
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )
    str_3 = "<ey?}N9I6\t9M]S"
    str_4 = "request_bytes"
    bool_2 = False
    router_2 = module_0.Router(str_3, str_4, stacking=bool_2, cascade_not_found=bool_2)
    str_5 = "\x0cU3Hf%C`U@^jqrD"
    float_0 = 1.1
    dict_0 = {}
    tuple_0 = (var_0, str_2, dict_0)
    str_6 = " workers"
    router_2.add(
        str_5,
        str_3,
        float_0,
        tuple_0,
        bool_1,
        version=bool_2,
        unquote=bool_0,
        version_prefix=str_6,
        error_format=str_1,
    )


@pytest.mark.xfail(strict=True)
def test_case_14():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    int_0 = 2454
    str_1 = "IL?YB"
    var_1 = var_0.add_parameter(int_0, none_type_0, str_1, str_1, type_0)
    list_0 = []
    router_0.finalize(*list_0)


@pytest.mark.xfail(strict=True)
def test_case_15():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(cascade_not_found=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    router_1 = module_0.Router(str_0, method_handler_exception=type_0)
    none_type_0 = None
    bool_0 = True
    var_0 = router_1.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_1.dynamic_routes) == 1
    assert len(router_1.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "7K\\7x_"
    var_1 = var_0.add_parameter(bool_0, str_1, none_type_0, str_1, type_0, var_0)
    str_2 = "!+<C"
    var_2 = var_0.__str__()
    assert var_2 == '<Route: name=l\\[afI(=" path=l\\[afI(=">'
    list_0 = [none_type_0]
    none_type_1 = router_1.finalize(*list_0)
    assert router_1.finalized is True
    assert (
        router_1.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    router_2 = module_0.Router()
    str_3 = "HTTP version"
    router_3 = module_0.Router(str_3, route_class=str_3, cascade_not_found=str_2)
    var_2.parse_parameter_string(str_1)
