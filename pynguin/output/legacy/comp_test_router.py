import pytest
from unittest.mock import MagicMock, patch
from sanic.exceptions import SanicException, NotFound, MethodNotAllowed
from router import Router, Route, RouteHandler, HTTP_METHODS


# Test suite for Router

@pytest.fixture
def router():
    return Router()

@pytest.fixture
def mock_route():
    return MagicMock(Route)

@pytest.fixture
def mock_handler():
    return MagicMock(RouteHandler)


# Test suite for the get method
def test_get_route(router, mock_route):
    path = "/test/route"
    method = "GET"
    host = None

    # Mock the resolve method to return a mock route
    router.resolve = MagicMock(return_value=(mock_route, mock_handler, {}))
    route, handler, match_info = router.get(path, method, host)

    # Ensure the route is returned correctly
    assert route == mock_route
    assert handler == mock_handler
    assert match_info == {}


# Test suite for routes_static property
def test_routes_static(router, mock_route):
    router.static_routes = {("static",): mock_route}
    route_dict = router.routes_static

    assert isinstance(route_dict, dict)
    assert mock_route in route_dict.values()


# Test suite for routes_dynamic property
def test_routes_dynamic(router, mock_route):
    router.dynamic_routes = {("dynamic",): mock_route}
    route_dict = router.routes_dynamic

    assert isinstance(route_dict, dict)
    assert mock_route in route_dict.values()


# Test suite for routes_regex property
def test_routes_regex(router, mock_route):
    router.regex_routes = {("regex",): mock_route}
    route_dict = router.routes_regex

    assert isinstance(route_dict, dict)
    assert mock_route in route_dict.values()



# Test suite for _normalize method (helper for routes)
def test_normalize_uri(router, mock_handler):
    uri = "/test/<param:int>"
    handler = mock_handler

    # Normalize the route URI and ensure that the parameter is handled correctly
    normalized_uri = router._normalize(uri, handler)
    assert normalized_uri == "/test/<param:int>"

# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import router as module_0
import sanic.constants as module_1
import collections.abc as module_2
import builtins as module_3
import abc as module_4


@pytest.mark.xfail(strict=True)
def test_case_0():
    none_type_0 = None
    router_0 = module_0.Router(
        method_handler_exception=none_type_0,
        route_class=none_type_0,
        group_class=none_type_0,
        stacking=none_type_0,
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert router_0.method_handler_exception is None
    assert router_0.route_class is None
    assert router_0.group_class is None
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is None
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    str_0 = 'l\\[afI(="'
    router_0.add(str_0, none_type_0, str_0, version=str_0, error_format=none_type_0)


def test_case_1():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0,
        none_type_0,
        type_0,
        strict_slashes=bool_0,
        ignore_body=type_0,
        version_prefix=str_0,
    )
    assert len(router_0.static_routes) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )


@pytest.mark.xfail(strict=True)
def test_case_2():
    type_0 = module_3.bytes
    type_1 = module_4.ABC
    type_2 = module_3.str
    bool_0 = False
    router_0 = module_0.Router(
        exception=type_0,
        method_handler_exception=type_1,
        route_class=type_2,
        stacking=bool_0,
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    str_0 = "iW3w;=S V;7#&I"
    bool_1 = True
    bool_2 = False
    bool_3 = True
    router_0.add(
        str_0,
        type_2,
        bool_1,
        strict_slashes=bool_0,
        unquote=bool_1,
        static=bool_2,
        version_prefix=type_2,
        overwrite=bool_3,
    )


def test_case_3():
    router_0 = module_0.Router()
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )


def test_case_4():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0,
        none_type_0,
        type_0,
        strict_slashes=bool_0,
        ignore_body=type_0,
        version_prefix=str_0,
    )
    assert len(router_0.static_routes) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    none_type_1 = router_0.finalize()
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    try:\n        group = router.static_routes[parts]\n        basket['__raw_path__'] = path\n        return group, basket\n    except KeyError:\n        pass\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    try:\n        group = router.static_routes[parts]\n        basket['__raw_path__'] = path\n        return (group, basket)\n    except KeyError:\n        pass\n    raise NotFound"
    )


@pytest.mark.xfail(strict=True)
def test_case_5():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "N}<*J7"
    router_1 = module_0.Router(str_0)
    router_0.add(str_1, router_0, var_0, none_type_0, name=str_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    bool_0 = False
    router_0 = module_0.Router(
        method_handler_exception=str_0, route_class=str_0, cascade_not_found=bool_0
    )
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert router_0.method_handler_exception == 'l\\[afI(="'
    assert router_0.route_class == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    bool_1 = False
    none_type_0 = None
    router_1 = module_0.Router(
        exception=none_type_0, method_handler_exception=bool_0, cascade_not_found=type_0
    )
    bool_2 = True
    str_1 = "ui]_rb.|\x0b"
    router_0.add(str_1, bool_0, bool_0, bool_2, stream=bool_1)


def test_case_7():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    var_1 = var_0.reset()
    var_2 = router_0.finalize(do_optimize=none_type_0)
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )


@pytest.mark.xfail(strict=True)
def test_case_8():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "!+<C"
    router_0.add(str_1, str_0, type_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    bool_0 = True
    bool_1 = False
    str_1 = "A^|~s?n\t_N/@fq"
    none_type_0 = None
    bool_2 = False
    router_0.add(
        str_1,
        bool_1,
        none_type_0,
        strict_slashes=bool_2,
        name=bool_0,
        unquote=bool_2,
        overwrite=bool_0,
        error_format=router_0,
    )


@pytest.mark.xfail(strict=True)
def test_case_10():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    var_1 = var_0.__str__()
    assert var_1 == '<Route: name=l\\[afI(=" path=l\\[afI(=">'
    list_0 = []
    none_type_1 = router_0.finalize(*list_0)
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )
    router_1 = module_0.Router()
    type_1 = module_3.BaseException
    router_2 = module_0.Router(bool_0, type_1)
    router_1.add(
        var_1,
        var_1,
        type_0,
        stream=none_type_1,
        ignore_body=none_type_1,
        version=router_1,
        static=var_1,
    )


@pytest.mark.xfail(strict=True)
def test_case_11():
    type_0 = module_2.Iterable
    str_0 = 'l\\[afI(="'
    type_1 = module_2.Iterable
    router_0 = module_0.Router(str_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    router_0.add(
        str_0,
        none_type_0,
        type_0,
        none_type_0,
        bool_0,
        ignore_body=str_0,
        version=str_0,
        version_prefix=type_1,
        error_format=router_0,
    )


@pytest.mark.xfail(strict=True)
def test_case_12():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "R\r823N}<@J#7"
    type_1 = module_3.dict
    str_2 = "<(\r\x0ca*F2nV\x0c2Px7m[H"
    router_1 = module_0.Router(str_2, cascade_not_found=str_2)
    router_2 = module_0.Router(router_1, none_type_0, stacking=str_1)
    str_3 = "{mRuet)th2y#"
    var_1 = router_0.reset()
    str_4 = '1fG/:)FfPVZ)LSPvls"@'
    var_2 = var_0.parse_parameter_string(str_4)
    bool_1 = False
    router_0.add(str_3, var_1, var_1, var_2, type_1, name=str_4, static=bool_1)


@pytest.mark.xfail(strict=True)
def test_case_13():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = False
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    bool_1 = False
    str_1 = "!+<C"
    router_1 = module_0.Router(str_0)
    str_2 = "Yc:;^*\\~y\x0bMjBM\t"
    none_type_1 = router_0.finalize()
    assert router_0.finalized is True
    assert (
        router_0.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    assert (
        router_0.find_route_src_compiled
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    if num == 1:\n        if parts[0] == '':\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            return (router.dynamic_routes['',][route_idx], basket)\n    raise NotFound"
    )
    str_3 = "<ey?}N9I6\t9M]S"
    str_4 = "request_bytes"
    bool_2 = False
    router_2 = module_0.Router(str_3, str_4, stacking=bool_2, cascade_not_found=bool_2)
    str_5 = "\x0cU3Hf%C`U@^jqrD"
    float_0 = 1.1
    dict_0 = {}
    tuple_0 = (var_0, str_2, dict_0)
    str_6 = " workers"
    router_2.add(
        str_5,
        str_3,
        float_0,
        tuple_0,
        bool_1,
        version=bool_2,
        unquote=bool_0,
        version_prefix=str_6,
        error_format=str_1,
    )


@pytest.mark.xfail(strict=True)
def test_case_14():
    str_0 = 'l\\[afI(="'
    type_0 = module_2.Iterable
    router_0 = module_0.Router(str_0, method_handler_exception=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == 'l\\[afI(="'
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert router_0.cascade_not_found is False
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    none_type_0 = None
    bool_0 = True
    var_0 = router_0.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_0.dynamic_routes) == 1
    assert len(router_0.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    int_0 = 2454
    str_1 = "IL?YB"
    var_1 = var_0.add_parameter(int_0, none_type_0, str_1, str_1, type_0)
    list_0 = []
    router_0.finalize(*list_0)


@pytest.mark.xfail(strict=True)
def test_case_15():
    str_0 = 'l\\[afI(="'
    type_0 = module_0.Router
    router_0 = module_0.Router(cascade_not_found=type_0)
    assert (
        f"{type(router_0).__module__}.{type(router_0).__qualname__}" == "router.Router"
    )
    assert router_0.static_routes == {}
    assert router_0.dynamic_routes == {}
    assert router_0.regex_routes == {}
    assert router_0.name_index == {}
    assert router_0.delimiter == "/"
    assert (
        f"{type(router_0.tree).__module__}.{type(router_0.tree).__qualname__}"
        == "sanic_routing.tree.Tree"
    )
    assert router_0.finalized is False
    assert router_0.stacking is False
    assert (
        f"{type(router_0.ctx).__module__}.{type(router_0.ctx).__qualname__}"
        == "types.SimpleNamespace"
    )
    assert (
        f"{type(router_0.regex_types).__module__}.{type(router_0.regex_types).__qualname__}"
        == "builtins.dict"
    )
    assert len(router_0.regex_types) == 10
    assert module_0.ROUTER_CACHE_SIZE == 1024
    assert module_0.ALLOWED_LABELS == ("__file_uri__",)
    assert module_0.Router.DEFAULT_METHOD == "GET"
    assert module_0.Router.ALLOWED_METHODS == (
        module_1.HTTPMethod.GET,
        module_1.HTTPMethod.POST,
        module_1.HTTPMethod.PUT,
        module_1.HTTPMethod.HEAD,
        module_1.HTTPMethod.OPTIONS,
        module_1.HTTPMethod.PATCH,
        module_1.HTTPMethod.DELETE,
    )
    assert (
        f"{type(module_0.Router.routes_all).__module__}.{type(module_0.Router.routes_all).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_static).__module__}.{type(module_0.Router.routes_static).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_dynamic).__module__}.{type(module_0.Router.routes_dynamic).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.Router.routes_regex).__module__}.{type(module_0.Router.routes_regex).__qualname__}"
        == "builtins.property"
    )
    router_1 = module_0.Router(str_0, method_handler_exception=type_0)
    none_type_0 = None
    bool_0 = True
    var_0 = router_1.add(
        str_0, none_type_0, none_type_0, str_0, stream=bool_0, name=str_0
    )
    assert len(router_1.dynamic_routes) == 1
    assert len(router_1.name_index) == 1
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "sanic_routing.route.Route"
    )
    str_1 = "7K\\7x_"
    var_1 = var_0.add_parameter(bool_0, str_1, none_type_0, str_1, type_0, var_0)
    str_2 = "!+<C"
    var_2 = var_0.__str__()
    assert var_2 == '<Route: name=l\\[afI(=" path=l\\[afI(=">'
    list_0 = [none_type_0]
    none_type_1 = router_1.finalize(*list_0)
    assert router_1.finalized is True
    assert (
        router_1.find_route_src
        == "def find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=\n    if num == 1:  # CHECK 1\n        if parts[0] == \"\":  # CHECK 4\n            if extra == {'host': 'l\\\\[afI(=\"'} and method in frozenset({'GET'}):\n                route_idx = 0\n            else:\n                raise NotFound\n            # Return 1\n            return router.dynamic_routes[('',)][route_idx], basket\n    raise NotFound\n"
    )
    router_2 = module_0.Router()
    str_3 = "HTTP version"
    router_3 = module_0.Router(str_3, route_class=str_3, cascade_not_found=str_2)
    var_2.parse_parameter_string(str_1)
import pytest
from sanic.router import Router
from sanic.exceptions import MethodNotAllowed, NotFound, SanicException
from sanic_routing.route import Route
@pytest.fixture
def router():
    return Router()
@pytest.fixture
def handler():
    async def sample_handler(request):
        return True
    return sample_handler
def test_add_route_with_host(router, handler):
    route = router.add("/test", ["GET"], handler, host="example.com")
    assert route.extra.hosts == ["example.com"]
def test_method_not_allowed(router, handler):
    router.add("/test", ["GET"], handler)
    router.finalize()
    with pytest.raises(MethodNotAllowed):
        router.get("/test", "POST", None)
def test_multiple_hosts(router, handler):
    routes = router.add(
        "/test",
        ["GET"],
        handler,
        host=["example.com", "api.example.com"]
    )
    assert len(routes) == 2
    assert isinstance(routes, list)
def test_find_route_by_view_name(router, handler):
    route = router.add("/test", ["GET"], handler, name="test_route")
    router.finalize()
    found_route = router.find_route_by_view_name("test_route")
    assert found_route == route
def test_normalize_uri_with_type_hints(router):
    async def handler(request, user_id: int, name: str):
        return True
    normalized = router._normalize("/user/<user_id>/name/<name>", handler)
    assert normalized == "/user/<user_id:int>/name/<name:str>"
def test_invalid_parameter_names(router, handler):
    router.add("/test/<__invalid>", ["GET"], handler)
    with pytest.raises(SanicException):
        router.finalize()
def test_router_properties(router, handler):
    # Add various types of routes
    router.add("/static", ["GET"], handler)
    router.add("/dynamic/<param>", ["GET"], handler)
    router.add("/regex/<param:[0-9]{4}>", ["GET"], handler)
    router.finalize()
    assert len(router.routes_static) == 1
    assert len(router.routes_dynamic) == 1
    assert len(router.routes_regex) == 1
    assert len(router.routes_all) == 3
def test_route_overwrite(router, handler):
    # First route
    router.add("/test", ["GET"], handler, name="test_route")
    # Overwrite with new route
    new_route = router.add("/test", ["GET"], handler, name="test_route", overwrite=True)
    router.finalize()
    found_route = router.find_route_by_view_name("test_route")
    assert found_route == new_route