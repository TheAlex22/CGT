# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import utils as module_0


@pytest.mark.xfail(strict=True)
def test_case_0():
    module_0.fn()


def test_case_1():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)
    list_0 = [var_0, var_0]
    var_1 = module_0.curry(var_0, var_0)
    var_2 = module_0.compose(tuple_0, *list_0)


def test_case_2():
    tuple_0 = ()
    var_0 = module_0.identity(tuple_0)


@pytest.mark.xfail(strict=True)
def test_case_3():
    none_type_0 = None
    module_0.increase(none_type_0)


def test_case_4():
    tuple_0 = ()
    var_0 = module_0.compose(tuple_0)


def test_case_5():
    tuple_0 = ()
    var_0 = module_0.pipe(tuple_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    bytes_0 = b"\x95\x1a_\xe1g'\xc0\xc2\xe1\xcb\xf9\x8b-\xb2\x1f\x17?"
    list_0 = [bytes_0, bytes_0, bytes_0, bytes_0]
    module_0.pipe(bytes_0, *list_0)


def test_case_7():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)


def test_case_8():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)
    list_0 = [var_0, var_0]
    var_1 = module_0.memoize(var_0, var_0)
    var_2 = module_0.compose(tuple_0, *list_0)


def test_case_9():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)
    list_0 = [var_0]
    var_1 = module_0.compose(tuple_0, *list_0)


@pytest.mark.xfail(strict=True)
def test_case_10():
    bool_0 = False
    list_0 = [bool_0, bool_0, bool_0]
    var_0 = module_0.cond(list_0)
    int_0 = module_0.increase(bool_0)
    assert int_0 == 1
    list_1 = [var_0]
    module_0.compose(list_1, *list_1)


@pytest.mark.xfail(strict=True)
def test_case_11():
    tuple_0 = ()
    var_0 = module_0.memoize(tuple_0, tuple_0)
    list_0 = [var_0, var_0]
    callable_0 = module_0.memoize(var_0, var_0)
    module_0.compose(tuple_0, *list_0)


@pytest.mark.xfail(strict=True)
def test_case_12():
    bool_0 = False
    var_0 = module_0.identity(bool_0)
    var_1 = module_0.curry(var_0, var_0)
    int_0 = module_0.increase(bool_0)
    assert int_0 == 1
    list_0 = [var_1]
    var_2 = module_0.compose(list_0, *list_0)
    var_3 = module_0.cond(var_2)
    int_1 = module_0.increase(var_0)
    assert int_1 == 1
    module_0.fn()


@pytest.mark.xfail(strict=True)
def test_case_13():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)
    callable_0 = module_0.memoize(var_0)
    list_0 = [callable_0]
    var_1 = module_0.compose(list_0, *list_0)
    var_2 = module_0.pipe(var_0, *list_0)
    module_0.increase(callable_0)


@pytest.mark.xfail(strict=True)
def test_case_14():
    tuple_0 = ()
    var_0 = module_0.cond(tuple_0)
    callable_0 = module_0.memoize(var_0)
    list_0 = [callable_0, callable_0]
    var_1 = module_0.compose(list_0, *list_0)
    var_2 = module_0.pipe(callable_0, *list_0)
    module_0.increase(callable_0)

import pytest
from utils import (
    curry, identity, increase, eq, curried_map, curried_filter,
    find, compose, pipe, cond, memoize
)

def test_identity():
    """Test identity function"""
    assert identity(1) == 1
    assert identity("test") == "test"
    assert identity(None) is None
    complex_obj = {"a": 1}
    assert identity(complex_obj) is complex_obj

def test_increase():
    """Test increase function"""
    assert increase(0) == 1
    assert increase(-1) == 0
    assert increase(999) == 1000

def test_curry():
    """Test curry function"""
    def add(a, b, c):
        return a + b + c
    
    curried_add = curry(add)
    assert curried_add(1)(2)(3) == 6
    assert curried_add(1, 2)(3) == 6
    assert curried_add(1)(2, 3) == 6
    assert curried_add(1, 2, 3) == 6

def test_eq():
    """Test eq function"""
    assert eq(1)(1) is True
    assert eq(1)(2) is False
    assert eq("test")("test") is True
    assert eq([1, 2])([1, 2]) is True

def test_curried_map():
    """Test curried_map function"""
    double = lambda x: x * 2
    assert curried_map(double)([1, 2, 3]) == [2, 4, 6]
    assert curried_map(str)([1, 2, 3]) == ["1", "2", "3"]
    assert curried_map(double)([]) == []

def test_curried_filter():
    """Test curried_filter function"""
    is_even = lambda x: x % 2 == 0
    assert curried_filter(is_even)([1, 2, 3, 4]) == [2, 4]
    assert curried_filter(lambda x: x > 2)([1, 2, 3, 4]) == [3, 4]
    assert curried_filter(is_even)([]) == []

def test_find():
    """Test find function"""
    numbers = [1, 2, 3, 4, 5]
    assert find(numbers, lambda x: x > 3) == 4
    assert find(numbers, lambda x: x > 5) is None
    assert find([], lambda x: True) is None

def test_pipe():
    """Test pipe function"""
    double = lambda x: x * 2
    add_one = lambda x: x + 1
    assert pipe(5, double, add_one) == 11
    assert pipe(5, add_one, double) == 12
    assert pipe(5) == 5

def test_cond():
    """Test cond function"""
    fn = cond([
        (lambda x: x > 10, lambda x: "big"),
        (lambda x: x < 5, lambda x: "small"),
        (lambda x: True, lambda x: "medium")
    ])
    
    assert fn(15) == "big"
    assert fn(3) == "small"
    assert fn(7) == "medium"

def test_memoize():
    """Test memoize function"""
    call_count = 0
    
    def expensive_fn(x):
        nonlocal call_count
        call_count += 1
        return x * 2
    
    memoized_fn = memoize(expensive_fn)
    
    assert memoized_fn(5) == 10
    assert call_count == 1
    assert memoized_fn(5) == 10
    assert call_count == 1  # Should not increase due to caching
    assert memoized_fn(6) == 12
    assert call_count == 2

def test_memoize_with_custom_key():
    """Test memoize function with custom key function"""
    call_count = 0
    
    def expensive_fn(x):
        nonlocal call_count
        call_count += 1
        return x * 2
    
    custom_key = lambda a, b: abs(a) == abs(b)
    memoized_fn = memoize(expensive_fn, key=custom_key)
    
    assert memoized_fn(5) == 10
    assert call_count == 1
    assert memoized_fn(-5) == 10  # Should use cached value
    assert call_count == 1

import pytest
from utils import (
    curry, identity, increase, eq, curried_map, curried_filter, find, compose, pipe, cond, memoize
)

# Test identity function
def test_identity():
    assert identity(5) == 5
    assert identity("test") == "test"
    assert identity([1, 2, 3]) == [1, 2, 3]

# Test increase function
def test_increase():
    assert increase(1) == 2
    assert increase(0) == 1
    assert increase(-1) == 0

# Test eq function (curried version)
def test_eq():
    eq_5 = eq(5)
    assert eq_5(5) is True
    assert eq_5(6) is False

# Test curried_map function
def test_curried_map():
    curried_double = curried_map(lambda x: x * 2)
    assert curried_double([1, 2, 3]) == [2, 4, 6]
    assert curried_double([0, -1, -2]) == [0, -2, -4]

# Test curried_filter function
def test_curried_filter():
    curried_even = curried_filter(lambda x: x % 2 == 0)
    assert curried_even([1, 2, 3, 4, 5]) == [2, 4]
    assert curried_even([1, 3, 5]) == []

# Test find function
def test_find():
    assert find([1, 2, 3, 4], lambda x: x == 3) == 3
    assert find([1, 2, 3], lambda x: x == 5) is None

# Test pipe function
def test_pipe():
    assert pipe(2, lambda x: x + 1, lambda x: x * 2) == 6
    assert pipe(3, lambda x: x - 1, lambda x: x ** 2) == 4

# Test cond function
def test_cond():
    condition = cond([
        (lambda x: x > 0, lambda x: "positive"),
        (lambda x: x < 0, lambda x: "negative"),
    ])
    assert condition(5) == "positive"
    assert condition(-1) == "negative"
    assert condition(0) is None  # No condition matches

# Test memoize function
def test_memoize():
    # Memoization should return cached results on subsequent calls
    def slow_function(x):
        return x * 2

    memoized_function = memoize(slow_function)

    # First call will compute the result
    assert memoized_function(2) == 4
    # Second call with the same argument should return the cached result
    assert memoized_function(2) == 4
    # Calling with a different argument should compute again
    assert memoized_function(3) == 6
